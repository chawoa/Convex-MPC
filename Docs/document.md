# Convex-MPC

## CONTROL ARCHITECTURE
### State Machine

### Swing Leg Control
공중에 있을때의 다리를 정확한 궤적으로 그리며 날아가도록 관절 모터의 힘.  
피드백 + 피드 포워드로 구성.  
$$\tau_i = J_i^\top [K_p(^B p_{i,\text{ref}} - ^B p_i) + K_d(^B v_{i,\text{ref}} - ^B v_i)] + \tau_{i,\text{ff}}$$  
  
피드백(대괄호): 목표 위치/속도($\text{ref}$)와 현재 위치/속도의 차이(오차)를 계산, 여기서 $K_p$는 강성, $K_d$는 감쇠력  
자코비안 ($J_i^\top$): 발끝에서 내야 하는 직선 방향의 힘을 각 관절(고관절, 무릎 등)의 회전력(토크)으로 변환 - 추가 공부  
    오일러 각 변화량($\dot{\Theta} = [\dot{\phi}, \dot{\theta}, \dot{\psi}]^\top$)은 축이 3번 연속으로 꺾이면서(Z축 돌고, 변한 Y축 돌고, 변한 X축 돌고) 측정되는 값입니다. 반면 각속도($\omega$)는 고정된 절대 공간(World)에서의 회전 속도입니다.따라서 "비틀어진 축 기준의 속도($\dot{\Theta}$)"를 "절대 공간 기준의 속도($\omega$)"로 변환해 주는 환율 계산기 같은 역할이 저 삼각함수 행렬입니다.  
피드포워드 토크 ($\tau_{i,\text{ff}}$): 다리 자체의 무게(중력 $G_i$), 관성($\Lambda_i$), 다리를 휘두를 때 생기는 원심력/코리올리 힘($C_i$)을 수학 모델을 통해 미리 계산  

로봇 다리가 쭉 펴져 있을 때와 굽혀져 있을 때, 모터가 느끼는 다리의 '관성(Apparent mass)'이 달라집니다.  
$$K_{p,i} = \omega_i^2 \Lambda_{i,i}$$  
이 수식은 다리의 자세가 변해서 관성($\Lambda_{i,i}$)이 변하더라도, 다리 제어의 고유 진동수($\omega_i$, 즉 반응하는 템포)가 일정하게 유지되도록 스프링 강성($K_p$)을 실시간으로 조절  

### Ground Force Control
발이 땅에 닿아 있는 동안, 로봇의 무거운 몸통을 지탱하고 원하는 방향으로 밀어내기 위해 관절 토크를 계산  
$$\tau_i = J_i^\top R_i^\top f_i$$  
  
$f_i$ (목표 지면 반력): 로봇 몸통의 밸런스를 잡고 앞으로 나아가기 위해 '발끝이 땅을 얼마나 세게 밀어야 하는가'를 나타내는 3차원 힘 벡터  
$R_i^\top$: 로봇 몸통 기준의 방향을 절대 세계(World) 좌표계로 변환하는 회전 행렬  
$J_i^\top$ (자코비안): 스윙 페이즈와 마찬가지로, 발끝에서 발생해야 하는 3차원 힘 벡터($f_i$)를 각 다리 관절 모터가 내야 할 회전력($\tau_i$)으로 변환  
  
## SIMPLIFIED ROBOT DYNAMICS
다리 무게는 제외: 로봇 전체 무게에 영향이 적음  
  
기본 법칙  
- 위치 이동: $\ddot{p} = \frac{\sum f_i}{m} - g$  
    (가속도 = 힘/질량 - 중력. 로봇 몸통이 지면 반력 $f_i$를 받아 앞뒤좌우로 움직이는 법칙), 지면 반력으로 위치 이동을 하기 때문  
- 회전: $\frac{d}{dt}(I\omega) = \sum r_i \times f_i$  
    $f_i$ (지면 반력): 발끝이 땅을 미는 힘 (예: 10kg의 힘으로 땅을 참)  
    $r_i$ (모멘트 암): 로봇의 무게중심(COM)에서 발끝(힘이 작용하는 곳)까지의 3차원 거리 벡터  
    $r_i \times f_i$ (외적, Cross Product): 거리와 힘을 곱해 '토크(회전력)'를 생성  
        [예시]: 문을 열 때, 문의 경첩(무게중심)에서 손잡이까지의 거리($r_i$)가 멀수록, 그리고 손으로 미는 힘($f_i$)이 셀수록 문이 더 휙휙 잘 도는(토크가 커지는) 것과 완벽히 같은 원리  
    $I$ (관성 텐서, Inertia): 물체가 회전하기 싫어하는 정도(무게와 모양에 따라 다름)  
    $\omega$ (각속도): 로봇이 빙글빙글 도는 속도  
    $I\omega$ (각운동량): 회전하는 물체가 가진 힘
    
    각도 변화:

    ```math
    \dot{R} = [\omega]_\times R
    ```

    여기서,
- **R** (회전 행렬): 로봇이 현재 월드 좌표계(절대 세계)에서 어느 방향으로 비틀어져 있는지를 나타내는 3x3 행렬
- **[ω]_×** (외적 행렬, Skew-symmetric matrix): 각속도 벡터 ω = [wₓ, w_y, w_z]^T를 3×3 행렬 모양으로 변환한 행렬
  
### Approximated Angular Velocity Dynamics
- 로봇은 심하게 기울어지지 않음 (방정식 8 ~ 12)  
    로봇의 자세는 Roll(좌우 기울기, $\phi$), Pitch(앞뒤 기울기, $\theta$), Yaw(회전, $\psi$)  
    방정식 9와 10은 각속도($\omega$)와 오일러 각의 변화량($\dot{\Theta}$)을 변환하는 식  
    보행 로봇이 바닥과 평행하게 걷는다고 가정 때문에 Roll과 Pitch는 0에 가깝게 아주 작다.   
    따라서 $\sin(0) = 0$, $\cos(0) = 1$이 됨  
    방정식 (11)과 (12)처럼 Yaw($\psi$) 하나만 남은 아주 단순한 곱셈 식으로 변합니다.  
  
- 로봇의 회전이 빠르지 않음 (방정식 13)  
    방정식 (6)의 원본을 풀면 $\frac{d}{dt}(I\omega) = I\dot{\omega} + \omega \times (I\omega)$  
    여기서 뒤쪽의 $\omega \times (I\omega)$는 회전이 빠를때 생기는 힘 (Precession, Nutation)  
    로봇이 얌전히 걷거나 뛸 때는 이 값이 0에 가까움  
    따라서 $I\dot{\omega}$  

- 관성 모멘트도 Yaw만 고려 (방정식 14, 15)  
    로봇이 기울어질 때마다 관성(회전하기 힘든 정도, $I$) 행렬이 변하는데 (방향 등이 변함?)  
    이것도 Roll과 Pitch가 작다고 치고 Yaw 회전($R_z(\psi)$)에 대한 관성만 계산  
  
### Simplified Robot Dynamics
행렬 합체 (방정식 16)  
현재 상태 + 입력으로 인한 상태 변화 + 중력 = 예측된 상태  
방정식 16을 아주 단순하게 요약하면 다음과 같은 형태  
(원래 12차원이지만, 이해를 돕기 위해 형태만 봅니다.)  
$$\dot{x}_{old} = A_{old}x_{old} + B_{old}u + G$$  
여기서 각 항목의 크기(차원)는 다음과 같습니다.  
$x_{old}$: 크기가 $12 \times 1$ 인 기존 상태 벡터 (각도, 위치, 속도 등)  
$A_{old}$: 크기가 $12 \times 12$ 인 시스템 행렬  
$G$: 크기가 $12 \times 1$ 인 중력 벡터입니다. 예시로는

```math
G = \begin{bmatrix} 0 \\ 0 \\ 0 \\ g \end{bmatrix}
```

(마지막 3칸만 중력 가속도 값을 가짐)  
  
아래와 같은 과정을 거쳐 17식으로 변형  
항상 값이 1인 가상의 상태(Dummy State)**를 하나 추가해서 13칸짜리 새로운 상태 벡터 $x_{new}$를 만듭니다.  
$$x_{new} = \begin{bmatrix} x_{old} \\ 1 \end{bmatrix}$$  
이때, 상수인 1을 시간에 대해 미분하면 0이 되므로, 좌변의 미분 벡터는 다음과 같이 됩니다.  
$$\dot{x}_{new} = \begin{bmatrix} \dot{x}_{old} \\ 0 \end{bmatrix}$$  
행렬 재배치: 중력을 A행렬 안으로 흡수이제 늘어난 상태 벡터($13 \times 1$)에 곱해질 수 있도록, $A_{old}$ 행렬($12 \times 12$)의 크기도 $13 \times 13$으로 키워야 합니다.  
이때 오른쪽 구석에 중력 벡터 $G$를 끼워 넣습니다.  
$$A_{new} = \begin{bmatrix} A_{old} & G \\ 0 \cdots 0 & 0 \end{bmatrix}$$  
$$B_{new} = \begin{bmatrix} B_{old} \\ 0 \cdots 0 \end{bmatrix}$$  
자, 이제 이 새로운 행렬들로 $\dot{x}_{new} = A_{new}x_{new} + B_{new}u$ 를 계산해 볼까요?  
행렬의 곱셈 규칙(행 $\times$ 열)을 그대로 따라가면 됩니다.  
$$\begin{bmatrix} \dot{x}_{old} \\ 0 \end{bmatrix} = \begin{bmatrix} A_{old} & G \\ 0 \cdots 0 & 0 \end{bmatrix} \begin{bmatrix} x_{old} \\ 1 \end{bmatrix} + \begin{bmatrix} B_{old} \\ 0 \cdots 0 \end{bmatrix} u$$  
위 식의 첫 번째 줄(원래 12칸의 영역)만 계산해서 풀어보면 다음과 같이 나옵니다.  
$A_{old}$ 부분은 $x_{old}$와 곱해집니다. ($A_{old} x_{old}$)오른쪽 끝에 심어둔 $G$는 맨 밑에 추가한 숫자 $1$과 곱해집니다.  
($G \times 1 = G$)  
$$\dot{x}_{old} = A_{old}x_{old} + G \cdot 1 + B_{old}u$$  
$$\dot{x}_{old} = A_{old}x_{old} + B_{old}u + G$$  
  
(방정식 17)  
$$\dot{x}(t) = A_c(\psi)x(t) + B_c(r_1,\ldots,r_n,\psi)u(t)$$  
(방정식 16에서 중력 $g$를 처리하기 위해 숫자 '1' 같은 더미 변수를 추가해서 13차원 행렬로 만듭니다.)  
$x(t)$ (상태): 로봇의 현재 기울기, 위치, 속도 등 (결과)  
$u(t)$ (입력): 4개의 발끝에서 땅을 밀어내는 힘($f_1, f_2, f_3, f_4$) (원인)  
$A_c$, $B_c$ (시스템 행렬): 로봇이 현재 바라보는 방향(Yaw, $\psi$)과 발 딛는 위치($r_i$)에만 영향을 받는 행렬.  

## MODEL PREDICTIVE CONTROL  
### Force Constraints
- 방정식 22 ($f_{\text{min}} \le f_z \le f_{\text{max}}$): Z축(위아래) 힘의 한계.  
    로봇 발은 땅을 '밀어낼' 수만 있지, 땅을 잡고 '당길' 수는 없습니다. (최소 힘 $\ge 0$). 또한 모터가 낼 수 있는 최대 힘 한계도 있습니다.  
- 방정식 23, 24 (마찰 원뿔, Friction Cone): X, Y 방향으로 미는 힘($f_x, f_y$)은 누르는 힘($f_z$)에 마찰 계수($\mu$)를 곱한 것보다 작아야 발이 미끄러지지 않습니다. 이를 컴퓨터가 계산하기 쉽게 원뿔 모양이 아닌 '사각뿔(Square pyramid)' 형태의 선형 부등식으로 단순화한 것입니다.  
  
## Reference Trajectory Generation
$x, y$ 속도와 Yaw(회전)만 명령을 따릅니다.  
Roll, Pitch, $Z$ 속도는 무조건 0으로 세팅  

## Linear Discrete Time Dynamics
연속 -> 이산  
$A_c, B_c$ -> $\hat{A}, \hat{B}$  
  
## QP Formulation
- 상태(X)를 소거해 버리기 (방정식 27)$x_1 = Ax_0 + Bu_0$ 이고,$x_2 = Ax_1 + Bu_1 = A(Ax_0 + Bu_0) + Bu_1$ 입니다.  
이런 식으로 전개하면, 미래의 모든 상태($X$)는 굳이 변수로 둘 필요 없이 "초기 상태($x_0$)와 미래의 힘($U$)들만의 곱셈"으로 싹 다 치환해버릴 수 있습니다!  
$$x_1 = Ax_0 + Bu_0$$  
$$x_2 = A(Ax_0 + Bu_0) + Bu_1 = A^2x_0 + ABu_0 + Bu_1$$  
$$x_3 = A^3x_0 + A^2Bu_0 + ABu_1 + Bu_2$$  
이 패턴을 미래의 $k$스텝까지 쫙 전개한 뒤 행렬로 묶어버리면, 거대한 덩어리인 $A_{qp}$ 행렬과 $B_{qp}$ 행렬이 만들어집니다.  
결국 컴퓨터는 매 스텝 복잡하게 $x$를 새로 계산할 필요 없이, "현재 상태 $x_0$에 상수 행렬 $A_{qp}$를 곱한 값"에 "미래에 가할 힘들의 모음 $U$에 상수 행렬 $B_{qp}$를 곱한 값"을 더하기만 하면 미래의 모든 궤적($X$)을 한 번에 예측할 수 있습니다.

- 초고속 최적화 형태로 변신 (방정식 28 ~ 32)방정식 28을 전개해서 예쁘게 정리하면, 방정식 29의 Standard QP (Quadratic Programming) 폼인 $\frac{1}{2} U^\top H U + U^\top g$ 형태가 나옵니다.  
방정식 28: 목표 궤적($y$, 논문에서는 $x_{\text{ref}}$)과 실제 궤적($X = A_{qp}x_0 + B_{qp}U$)의 차이를 줄이고, 힘($U$)도 최소한으로 쓰겠다는 목적 함수입니다.

```math
J(U) = \|A_{qp}x_0 + B_{qp}U - y\|_L^2 + \|U\|_K^2
```

2차항 (U^2 항):
```math
U^\top (B_{qp}^\top L B_{qp} + K) U
```

1차항 (U 항):
```math
U^\top (2 B_{qp}^\top L (A_{qp}x_0 - y))
```

상수항:
```math
(A_{qp}x_0 - y)^\top L (A_{qp}x_0 - y)
```
여기서 최적화(미분해서 0이 되는 지점 찾기)를 할 때 상수항은 어차피 사라지므로 버립니다.  
이제 컴퓨터 최적화 라이브러리가 요구하는 표준 QP 형태(방정식 29)와 모양을 똑같이 맞춰봅니다.  
$$\min \frac{1}{2} U^\top H U + U^\top g$$  
위에서 구한 2차항, 1차항과 계수 비교를 딱 해보면 방정식 31, 32가 튀어나옵니다!  
방정식 31 ($H$ 행렬): $2차항 계수 = \frac{1}{2} H \implies \mathbf{H = 2(B_{qp}^\top L B_{qp} + K)}$  
방정식 32 ($g$ 벡터): $1차항 계수 = g \implies \mathbf{g = 2 B_{qp}^\top L (A_{qp}x_0 - y)}$  

원래는 컴퓨터가 "최적의 궤적($X$)"과 "최적의 힘($U$)" 두 개를 동시에 찾아야 했습니다. 하지만 이 기법을 쓰면 변수 $X$가 아예 삭제됩니다.  
행렬 $H$의 크기를 보면, 상태 변수 개수($13k$)는 쏙 빠지고 오직 제어해야 할 발의 힘 개수($3nk$)만 남습니다. 문제가 엄청나게 작아지고 가벼워진 것입니다.  